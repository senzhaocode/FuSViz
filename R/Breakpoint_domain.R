#' Tag breakpoint position in each transcript (concatenated exons by reducing introns) of partner genes
#'
#' @description Tag breakpoint position in each transcript (e.g. at exon boundary/within exon or within intron, exon rank) of partner genes
#'              for two-way plotting in domain tab-panel
#'
#' @param breakpoint A numeric vector (containing only one element) represents genomic coordinate of geneA / geneB breakpoint.
#' @param object A list collects geneA / geneB breakpoint annotation, two keys elements (i.e. a GRange object: \code{object\$txTr_f}, a data.frame object: \code{object\$dataset}).
#' @param whole_tx A GRange object - exon intervals grouped by transcript per gene, which was generated by processing \code{txdb_ref} object.
#'
#' @return A list with three data.frame elements (i.e. \code{transcript}, \code{select_region} and \code{breakpoint_collect}) with transcript and breakpoint annotations of partner genes
#'
#' @export
gene_trans_ex_reduce <- function(breakpoint, object, whole_tx) {
	# For testing: breakpoint = breakpoint_set[2,2]; object; whole_tx = whole_txdb
	dataset = object$dataset
	start = object$start
	end = object$end
	strand = object$strand
	chr = object$chr
	txTr_f = object$txTr_f

	#// if breakpoint outside of gene, return NULL
	if ( breakpoint < start || breakpoint > end ) { return(NULL) }
	#// if strand is negative, convert breakpoint to a negative value
	if ( strand == "-" ) { breakpoint = 0 - breakpoint; } 

	select_region_f = NULL; #// a data.frame class to collect annotations and structures (5utr-cds-utr3) of transcripts for geneA or geneB
	JE = NULL; #// a data.frame to collect breakpoint judgement (1, 2, 3 or 4), exon_number, transcript_length and exon_id harboring breakpoint or close to breakpoint
	breakpoint_collect= NULL; #// collect breakpoint relative postions in the transcript
	for ( x in 1:length(dataset[,1])) { #// not important whether x is either character or numeric
		name = dataset[x,]$TXNAME #// transcript_id e.g. name = "ENST00000398585"

		if ( strand == "+" ) {
			#// if breakpoint falls out of transcript range (for + strand), come to next one
			if ( breakpoint < dataset[x,]$TXSTART || breakpoint > dataset[x,]$TXEND ) { 
				tmp = cbind(t(0), t(NA), t(NA), t(NA), t(0), t(NA), t(NA), t(chr), t(strand), t(start), t(end));
				JE = rbind(JE, tmp, deparse.level=0); #// row extension 
				next;
			}
			all_exon_tx_A = whole_tx[[name]]
		} else { #// if negative strand, reverse exon order
			#// if breakpoint falls out of transcript range (for - strand), come to next one
			if ( breakpoint < (0 - dataset[x,]$TXEND) || breakpoint > (0 - dataset[x,]$TXSTART) ) { 
				tmp = cbind(t(0), t(NA), t(NA), t(NA), t(0), t(NA), t(NA), t(chr), t(strand), t(start), t(end));
				JE = rbind(JE, tmp, deparse.level=0); #// row extension 
				next;
			}
			all_exon_tx_A = rev(whole_tx[[name]])
		}

		#// assign exon names if they are missing in GRange object (shown as "5-utr-cds-utr-3 structure" in txTr_f)
		ref_point = GenomicRanges::findOverlaps(txTr_f[Gviz::transcript(txTr_f)==name]@range, all_exon_tx_A) #// run GRange overlapping
		#// set exon_name
		txTr_f@range@elementMetadata[txTr_f@range@elementMetadata$transcript==name,]$exon[S4Vectors::queryHits(ref_point)] = all_exon_tx_A$exon_name[S4Vectors::subjectHits(ref_point)]
		region_f = as.data.frame(txTr_f[Gviz::transcript(txTr_f)==name]@range) #// convert GeneRegionTrack(Rle) to data.frame structure

		#// get exon (utr+cds) structure
		region_f_group = as.data.frame(all_exon_tx_A); #// convert GeneRegionTrack(Rle) to data.frame structure (exon as unit)
		colnames(region_f_group)[7] = "exon"
		colnames(region_f_group)[8] = "EXONRANK"

		#// define 'region_f_relative' and 'region_f_group_relative' for relative coordiantes at the transcript level
		breakpoint_relative = NULL; #// a GRange class - calculate the relative position [0 - transcript_length] of breakpoint in the transcript
		region_f_relative = NULL; #// a GRange class - calculate the relative position [0 - transcript_length] of 5utr-cds-utr3 in the transcript
		region_f_group_relative = NULL; #// a GRange class - calculate the relative position [0 - transcript_length] of exon in the transcript
		if ( strand == "+" ) { #// e.g. start=c(3, 9, 20, 35) end=c(5, 15, 30, 49)
			region_f_relative = IRanges::IRanges(start = region_f$start, end = region_f$end)
			region_f_group_relative = IRanges::IRanges(start = region_f_group$start, end = region_f_group$end)
			breakpoint_relative = IRanges::IRanges(start = breakpoint, end = breakpoint);
		} else { #// if negative strand, convert coordinate to negative value, e.g. start=c(-49, -30, -15, -5) end=c(-35, -20, -9, -3)
			region_f = region_f[rev(order(region_f$start)),] #// reverse coordinate
			start_tmp = 0 - region_f$end; end_tmp = 0 - region_f$start;
			region_f_relative = IRanges::IRanges(start = start_tmp, end = end_tmp)
				
			region_f_group = region_f_group[rev(order(region_f_group$start)), ] #// reverse coordinate
			region_f_group_relative <- IRanges::IRanges(start = 0 - region_f_group$end, end = 0 - region_f_group$start)
			region_f_group$start = start(region_f_group_relative)
			region_f_group$end = end(region_f_group_relative)
			breakpoint_relative = IRanges::IRanges(start = breakpoint, end = breakpoint);
		}
			
		flag = NULL; #// a tag used for marking the exon in which breakpoint falls or is closed
		Judge = 0; Exon_num = 0; #// Judge=1 (at exon boundary), 2 (within exon), 3 (within intron)
		#// process 'region_f_group_relative' and 'breakpoint_relative' (reduce intron and calculate relative coordinates)
		#// NOTE: if breakpoint within intron, we regard the breakpoint at the end_boundary of front exon and assume no intron sequences are included in reduced transcripts
		if ( length(region_f_group[,1]) == 1 ) { #// if the transcript has only one exon
			tmp_shift = 1 - start(region_f_group_relative[1])
			region_f_group_relative[1] = IRanges::shift(region_f_group_relative[1], shift = tmp_shift)
			if ( breakpoint >= region_f_group[1,]$start && region_f_group[1,]$end >= breakpoint ) { #// breakpoint at exon boundary or within exon
				prop = (breakpoint - region_f_group[1,]$start + 1)/(region_f_group[1,]$end - region_f_group[1,]$start + 1); #// 0 <= prop <= 1
				flag = region_f_group[1,]; flag[,"Prop"] = prop;
				if ( breakpoint == region_f_group[1,]$start || region_f_group[1,]$end == breakpoint ) { #// breakpoint at exon boundary
					Judge = 1; Exon_num = region_f_group[1,]$EXONRANK
				} else { #// breakpoint within exon
					Judge = 2; Exon_num = region_f_group[1,]$EXONRANK
				}
				breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_shift)
			} 
		} else { #// the transcript has more than one exon
			y = length(region_f_group[,1]) - 1
			for (z in 1:y) {
				if (z == 1) { #// if loop at the first exon
					tmp_shift = 1 - start(region_f_group_relative[z]);
					region_f_group_relative[z] = IRanges::shift(region_f_group_relative[z], shift = tmp_shift)
				} else {
					tmp_shift = 0 - (start(region_f_group_relative[z]) - end(region_f_group_relative[z-1])) + 1; 
					region_f_group_relative[z] = IRanges::shift(region_f_group_relative[z], shift = tmp_shift)
				}
						
				if ( breakpoint >= region_f_group[z,]$start && breakpoint <= region_f_group[z,]$end ) { #// breakpoint at exon boundary or within exon
					prop = (breakpoint - region_f_group[z,]$start + 1)/(region_f_group[z,]$end - region_f_group[z,]$start + 1); #// 0 <= prop <= 1
					flag = region_f_group[z,]; flag[,"Prop"] = prop
					if ( breakpoint == region_f_group[z,]$start || region_f_group[z,]$end == breakpoint ) { #// breakpoint at exon boundary
						Judge = 1; Exon_num = region_f_group[z,]$EXONRANK
					} else { #// breakpoint within exon
						Judge = 2; Exon_num = region_f_group[z,]$EXONRANK
					}
					breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_shift)
					break; #// quit the loop
				} else if ( breakpoint > region_f_group[z,]$end && region_f_group[z+1,]$start > breakpoint ) { #// breakpoint within intron
					prop = 1; #// regard breakpoint at the end of exon [z]
					flag = region_f_group[z,]; flag[,"Prop"] = prop
					Judge = 3; Exon_num = paste(region_f_group[z,]$EXONRANK, '-', region_f_group[z+1,]$EXONRANK, sep="")
					end_to_breakpoint = end(region_f_group_relative[z])
					breakpoint_relative = IRanges::IRanges(start=end_to_breakpoint, end=end_to_breakpoint)
					break; #// quit the loop
				}
					
				if ( z == y ) { #// loop at the second last exon
					tmp_plus_shift = 0 - (start(region_f_group_relative[z+1]) - end(region_f_group_relative[z])) + 1; 
					region_f_group_relative[z+1] = IRanges::shift(region_f_group_relative[z+1], shift = tmp_plus_shift)
					if ( breakpoint >= region_f_group[z+1,]$start && region_f_group[z+1,]$end >= breakpoint ) { #// breakpoint at the boundary or within the last exon
						prop = (breakpoint - region_f_group[z+1,]$start + 1)/(region_f_group[z+1,]$end - region_f_group[z+1,]$start + 1); #// 0 <= prop <= 1
						flag = region_f_group[z+1,]; flag[,"Prop"] = prop
						if ( breakpoint == region_f_group[z+1,]$start || region_f_group[z+1,]$end == breakpoint ) { #// breakpoint at exon boundary
							Judge = 1; Exon_num = region_f_group[z+1,]$EXONRANK
						} else { #// breakpoint within exon
							Judge = 2; Exon_num = region_f_group[z+1,]$EXONRANK
						}
						breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_plus_shift)
						break; #// quit the loop
					}
				}
			}
		}
		if ( !is.null(flag) ) { 
			Exon_max = max(region_f_group$EXONRANK) #// get total exon number of the transcript
			Trans_length = dataset[x,]$TXEND - dataset[x,]$TXSTART + 1; #// get transcript length
			tmp = cbind(t(Judge), t(flag$Prop), t(flag$EXONRANK), t(flag$exon), t(Exon_num), t(Exon_max), t(Trans_length), t(chr), t(strand), t(start), t(end));
			JE = rbind(JE, tmp, deparse.level=0); #// extend row of JE data.frame (including Judge, flag, Exon_num....)
			breakpoint_current = start(breakpoint_relative); names(breakpoint_current) = name;
			breakpoint_collect = c(breakpoint_collect, breakpoint_current)
		} else {
			tmp = cbind(t(Judge), t(NA), t(NA), t(NA), t(Exon_num), t(NA), t(NA), t(chr), t(strand), t(start), t(end));
			JE = rbind(JE, tmp, deparse.level=0); #// row extension 
		} 
		if ( !is.null(region_f_relative) ) { #// Ideally, region_f_relative should not be NULL
			#// 'region_f_relative' (reduce intron and calculate relative coordinates)
			for (i in seq_along(region_f_relative)) {
				if (i == 1) {
					region_f_relative[i] = IRanges::shift(region_f_relative[i], shift = 1 - start(region_f_relative[i]))
				} else {
					tmp_shift = 0 - (start(region_f_relative[i]) - end(region_f_relative[i-1])) + 1
					region_f_relative[i] = IRanges::shift(region_f_relative[i], shift = tmp_shift)
				}
			}
			region_f$start = start(region_f_relative) #// replace relative start coordinates to absolute start coordinates in 'region_f'
			region_f$end = end(region_f_relative) #// replace relative end coordinates to absolute end coordinates in 'region_f'
			dataset[x,]$TXSTART = min(region_f$start); #// start of transcript in 'dataset' after reducing intron
			dataset[x,]$TXEND = max(region_f$end); #// end of transcript in 'dataset' after reducing intron
			select_region_f = rbind(select_region_f, region_f) 
		} else {
			stop("Unexpected exon relative coordinate, a bug needs to be fixed!");
		}
	}
	#// build 'transcript' data.frame class, which combines info of dataset and JE (removing rows with NA)
	transcript = cbind(as.data.frame(cbind(dataset$GENEID, dataset$TXNAME, dataset$TXSTART, dataset$TXEND)), JE); 
	transcript = na.omit(transcript) #// remove all NA rows
	if (! is.na(transcript[1,1]) ) {
		names(transcript) = c("GENEID", "TXNAME", "TXSTART", "TXEND", "Judge", "Prop", "EXONRANK", "exon", "Exon_pos", "Exon_num", "Trans_length", "Chrom", "Strand", "GStart", "GEnd")
		transcript$TXSTART = as.numeric(transcript$TXSTART) #// switch to numeric type
		transcript$TXEND = as.numeric(transcript$TXEND) #// switch to numeric type
		transcript$Prop = as.numeric(transcript$Prop)	#// switch to the numeric type
		transcript$EXONRANK = as.numeric(transcript$EXONRANK) #// switch to the numeric type
		transcript$exon = as.character(transcript$exon) #// switch to the string type for exon name
		transcript$Exon_pos = as.character(transcript$Exon_pos) #// switch to the numeric type
		transcript$Exon_num = as.numeric(as.character(transcript$Exon_num)) #// switch to the numeric type
		transcript$Trans_length = as.numeric(as.character(transcript$Trans_length)) #// switch to the numeric type
		transcript$Strand = as.character(transcript$Strand) #// switch to the charater type
		transcript$GStart = as.numeric(as.character(transcript$GStart)) #// switch to the numeric type
		transcript$GEnd = as.numeric(as.character(transcript$GEnd)) #// switch to the numeric type
		#-# levels(transcript$Chrom) = sub("^chr", "", levels(transcript$Chrom), ignore.case=T) #// remove 'chr' 
		#// 'transcript' is a data.frame class used for evaluating breakpoint pos in each transcript, and 'select_region_f' is a data.frame class used for plotTracks
		assemble <- list(transcript=transcript, select_region=select_region_f, breakpoint_collect = breakpoint_collect)
	} else {
		assemble <- list(transcript=NULL, select_region=NULL, breakpoint_collect=NULL)
	}
	return(assemble)
}

