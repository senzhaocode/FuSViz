#' Tag breakpoint position in each transcript (concatenated exons by reducing introns) of partner genes
#'
#' @description Tag breakpoint position in each transcript (e.g. at exon boundary/within exon or within intron, exon rank) of partner genes
#'              for two-way plotting in domain tab-panel
#'
#' @param breakpoint A numeric vector (only one element) represents genomic coordinate of geneA / geneB breakpoint.
#' @param object A list collects geneA / geneB breakpoint annotation, two key elements (i.e. a GRange object: \code{object\$txTr_f}, a data.frame object: \code{object\$dataset}).
#' @param whole_tx A GRange object - exon interval grouped by transcript per gene, which was generated by processing \code{txdb_ref} object.
#' @param AB_order A string value - either 'upstream' or 'downstream'.
#' @param offset A numeric value - set a offset value to adjust breakpoint deviation (default: 5).
#'
#' @return A list has three data.frame elements (i.e. \code{transcript}, \code{select_region} and \code{breakpoint_collect}) with transcript and breakpoint annotations of partner genes
#'
#' @export
gene_trans_ex_reduce <- function(breakpoint, object, whole_tx, AB_order, offset) {
	print(paste("offset value: ", offset, sep=''))
	# For testing: breakpoint = breakpoint_set[2,2]; object; whole_tx = whole_txdb; AB_order = "upstream" or "downstream"; offset = 5 (defalut) for breakpoint deviation
	dataset = object$dataset
	start = object$start
	end = object$end
	strand = object$strand
	chr = object$chr
	txTr_f = object$txTr_f

	#// if breakpoint outside of gene, return NULL
	if ( breakpoint < start || breakpoint > end ) { return(NULL) }
	#// if strand is negative, convert breakpoint to a negative value
	if ( strand == "-" ) { breakpoint = 0 - breakpoint; } 
	if (! is(AB_order, "character") ) { stop("AB_order not character!"); }
	if (! is(offset, "numeric") ) { stop("offset not numeric!"); }
	if ( AB_order == "upstream" || AB_order == "downstream" ) {} else { stop("value of AB_order is either upstream or downsream!"); }

	select_region_f = NULL; #// a data.frame class to collect annotations and structures (5utr-cds-utr3) of transcripts for geneA or geneB
	JE = NULL; #// a data.frame to collect breakpoint judgement (1, 2, 3 or 4), exon_number, transcript_length and exon_id harboring breakpoint or close to breakpoint
	breakpoint_collect= NULL; #// collect breakpoint relative postions in the transcript
	for ( x in 1:length(dataset[,1])) { #// not important whether x is either character or numeric
		name = dataset[x,]$TXNAME #// transcript_id e.g. name = "ENST00000398585"

		if ( strand == "+" ) {
			#// if breakpoint falls out of transcript range (for + strand), come to next one
			if ( breakpoint < dataset[x,]$TXSTART || breakpoint > dataset[x,]$TXEND ) { 
				tmp = cbind(t(0), t(NA), t(NA), t(NA), t(0), t(NA), t(NA), t(chr), t(strand), t(start), t(end));
				JE = rbind(JE, tmp, deparse.level=0); #// row extension 
				next;
			}
			all_exon_tx_A = whole_tx[[name]]
		} else { #// if negative strand, reverse exon order
			#// if breakpoint falls out of transcript range (for - strand), come to next one
			if ( breakpoint < (0 - dataset[x,]$TXEND) || breakpoint > (0 - dataset[x,]$TXSTART) ) { 
				tmp = cbind(t(0), t(NA), t(NA), t(NA), t(0), t(NA), t(NA), t(chr), t(strand), t(start), t(end));
				JE = rbind(JE, tmp, deparse.level=0); #// row extension 
				next;
			}
			all_exon_tx_A = rev(whole_tx[[name]])
		}

		#// assign exon names if they are missing in GRange object (shown as "5-utr-cds-utr-3 structure" in txTr_f)
		ref_point = GenomicRanges::findOverlaps(txTr_f[Gviz::transcript(txTr_f)==name]@range, all_exon_tx_A) #// run GRange overlapping
		#// set exon_name
		txTr_f@range@elementMetadata[txTr_f@range@elementMetadata$transcript==name,]$exon[S4Vectors::queryHits(ref_point)] = all_exon_tx_A$exon_name[S4Vectors::subjectHits(ref_point)]
		region_f = as.data.frame(txTr_f[Gviz::transcript(txTr_f)==name]@range) #// convert GeneRegionTrack(Rle) to data.frame structure

		#// get exon (utr+cds) structure
		region_f_group = as.data.frame(all_exon_tx_A); #// convert GeneRegionTrack(Rle) to data.frame structure (exon as unit)
		colnames(region_f_group)[7] = "exon"
		colnames(region_f_group)[8] = "EXONRANK"

		#// define 'region_f_relative' and 'region_f_group_relative' for relative coordiantes at the transcript level
		breakpoint_relative = NULL; #// a GRange class - calculate the relative position [0 - transcript_length] of breakpoint in the transcript
		region_f_relative = NULL; #// a GRange class - calculate the relative position [0 - transcript_length] of 5utr-cds-utr3 in the transcript
		region_f_group_relative = NULL; #// a GRange class - calculate the relative position [0 - transcript_length] of exon in the transcript
		if ( strand == "+" ) { #// e.g. start=c(3, 9, 20, 35) end=c(5, 15, 30, 49)
			region_f_relative = IRanges::IRanges(start = region_f$start, end = region_f$end)
			region_f_group_relative = IRanges::IRanges(start = region_f_group$start, end = region_f_group$end)
			breakpoint_relative = IRanges::IRanges(start = breakpoint, end = breakpoint);
		} else { #// if negative strand, convert coordinate to negative value, e.g. start=c(-49, -30, -15, -5) end=c(-35, -20, -9, -3) in transcribed direction 5utr->3utr
			region_f = region_f[rev(order(region_f$start)),] #// reverse coordinate
			start_tmp = 0 - region_f$end; end_tmp = 0 - region_f$start;
			region_f_relative = IRanges::IRanges(start = start_tmp, end = end_tmp)
				
			region_f_group = region_f_group[rev(order(region_f_group$start)), ] #// reverse coordinate
			region_f_group_relative <- IRanges::IRanges(start = 0 - region_f_group$end, end = 0 - region_f_group$start)
			region_f_group$start = IRanges::start(region_f_group_relative)
			region_f_group$end = IRanges::end(region_f_group_relative)
			breakpoint_relative = IRanges::IRanges(start = breakpoint, end = breakpoint);
		}
			
		flag = NULL; #// a tag used for marking the exon in which breakpoint falls or is closed
		Judge = 0; Exon_num = 0; #// Judge=1 (at exon boundary), 2 (within exon), 3 (within intron)
		#// process 'region_f_group_relative' and 'breakpoint_relative' (reduce intron and calculate relative coordinates)
		#// NOTE: if breakpoint within intron, we regard the breakpoint at the end_boundary of front exon and assume no intron sequences are included in reduced transcripts
		if ( length(region_f_group[,1]) == 1 ) { #// if the transcript has only one exon
			tmp_shift = 1 - IRanges::start(region_f_group_relative[1])
			region_f_group_relative[1] = IRanges::shift(region_f_group_relative[1], shift = tmp_shift)
			if ( breakpoint >= region_f_group[1,]$start && region_f_group[1,]$end >= breakpoint ) { #// breakpoint at exon boundary or within exon
				prop = (breakpoint - region_f_group[1,]$start + 1)/(region_f_group[1,]$end - region_f_group[1,]$start + 1); #// 0 <= prop <= 1
				flag = region_f_group[1,]; flag[,"Prop"] = prop;
				if ( breakpoint == region_f_group[1,]$start || region_f_group[1,]$end == breakpoint ) { #// breakpoint at exon boundary
					Judge = 1; Exon_num = region_f_group[1,]$EXONRANK
				} else { #// breakpoint within exon
					Judge = 2; Exon_num = region_f_group[1,]$EXONRANK
				}
				breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_shift)
			} 
		} else { #// the transcript has more than one exon
			y = length(region_f_group[,1]) - 1
			for (z in 1:y) {
				if (z == 1) { #// if loop at the first exon
					tmp_shift = 1 - IRanges::start(region_f_group_relative[z]);
					region_f_group_relative[z] = IRanges::shift(region_f_group_relative[z], shift = tmp_shift)
				} else {
					tmp_shift =	- (IRanges::start(region_f_group_relative[z]) - IRanges::end(region_f_group_relative[z-1])) + 1; 
					region_f_group_relative[z] = IRanges::shift(region_f_group_relative[z], shift = tmp_shift)
				}
						
				if ( breakpoint >= region_f_group[z,]$start && breakpoint <= region_f_group[z,]$end ) { #// breakpoint at exon boundary or within exon
					prop = (breakpoint - region_f_group[z,]$start + 1)/(region_f_group[z,]$end - region_f_group[z,]$start + 1); #// 0 <= prop <= 1
					flag = region_f_group[z,]; flag[,"Prop"] = prop
					Exon_num = region_f_group[z,]$EXONRANK
					if ( breakpoint == region_f_group[z,]$start || region_f_group[z,]$end == breakpoint ) { #// breakpoint at exon boundary
						Judge = 1; 
						breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_shift)
					} else { #// breakpoint within exon
						m = 1; # set start point = 1
						while ( m <= offset ) { # if breakpoint does not match to exon boundrary exactly, and use a offset value for adjustment
							if ( AB_order == "upstream" ) {
								breakpoint_up = breakpoint + m;
								if ( breakpoint_up == region_f_group[z,]$start || region_f_group[z,]$end == breakpoint_up ) { #// breakpoint at exon boundary
									Judge = 1;
									breakpoint_up_relative = IRanges::IRanges(start = breakpoint_up, end = breakpoint_up);
									breakpoint_relative = IRanges::shift(breakpoint_up_relative, shift = tmp_shift);
									break;
								}
							} else {  # downstream
								if ( z > 1 ) { # for downstream partner, start from the 2nd exon
									breakpoint_down = breakpoint - m;
									if ( breakpoint_down == region_f_group[z,]$start || region_f_group[z,]$end == breakpoint_down ) { #// breakpoint at exon boundary
										Judge = 1;
										breakpoint_down_relative = IRanges::IRanges(start = breakpoint_down, end = breakpoint_down);
										breakpoint_relative = IRanges::shift(breakpoint_down_relative, shift = tmp_shift);
										break;
									}
								}
							}
							m = m + 1;
						}
						if ( m > offset ) {
							Judge = 2;
							breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_shift)
						}
					}
					break; #// quit the loop
				} else if ( breakpoint > region_f_group[z,]$end && region_f_group[z+1,]$start > breakpoint ) { #// breakpoint within intron
					Exon_num = paste(region_f_group[z,]$EXONRANK, '-', region_f_group[z+1,]$EXONRANK, sep="")
					end_to_breakpoint = IRanges::end(region_f_group_relative[z])
					m = 1; # set start point = 1
					while ( m <= offset ) { # if breakpoint does not match to exon boundrary exactly, and set a offset value with maximum 5 bp
						if ( AB_order == "upstream" ) {
							breakpoint_down = breakpoint - m;
							if ( breakpoint_down >= region_f_group[z,]$start && breakpoint_down <= region_f_group[z,]$end ) { #// breakpoint at exon boundary or within exon
								prop = (breakpoint_down - region_f_group[z,]$start + 1)/(region_f_group[z,]$end - region_f_group[z,]$start + 1); #// 0 <= prop <= 1
								flag = region_f_group[z,]; flag[,"Prop"] = prop
								Judge = 1;
								breakpoint_relative = IRanges::IRanges(start=end_to_breakpoint, end=end_to_breakpoint)
								break;
							}
						} else if ( AB_order == "downstream" ) { # downstream
							breakpoint_up = breakpoint + m;
							if ( breakpoint_up >= region_f_group[z+1,]$start && breakpoint_up <= region_f_group[z+1,]$end ) { #// breakpoint at exon boundary or within exon
								prop = (breakpoint_up - region_f_group[z+1,]$start + 1)/(region_f_group[z+1,]$end - region_f_group[z+1,]$start + 1); #// 0 <= prop <= 1
								flag = region_f_group[z+1,]; flag[,"Prop"] = prop
								Judge = 1;
								breakpoint_relative = IRanges::IRanges(start=end_to_breakpoint+1, end=end_to_breakpoint+1)
								break;
							}
						} else {
							stop("AB_order name should be upstream or downstream!");
						}
						m = m + 1;
					}
					if ( m > offset ) {
						prop = 1; #// regard breakpoint at the end of exon [z]
						flag = region_f_group[z,]; flag[,"Prop"] = prop
						Judge = 3;
						breakpoint_relative = IRanges::IRanges(start=end_to_breakpoint, end=end_to_breakpoint)
					}	
					break; #// quit the loop
				}
					
				if ( z == y ) { #// loop at the second last exon
					tmp_plus_shift = - (IRanges::start(region_f_group_relative[z+1]) - IRanges::end(region_f_group_relative[z])) + 1; 
					region_f_group_relative[z+1] = IRanges::shift(region_f_group_relative[z+1], shift = tmp_plus_shift)
					if ( breakpoint >= region_f_group[z+1,]$start && region_f_group[z+1,]$end >= breakpoint ) { #// breakpoint at the boundary or within the last exon
						prop = (breakpoint - region_f_group[z+1,]$start + 1)/(region_f_group[z+1,]$end - region_f_group[z+1,]$start + 1); #// 0 <= prop <= 1
						flag = region_f_group[z+1,]; flag[,"Prop"] = prop
						Exon_num = region_f_group[z+1,]$EXONRANK
						if ( breakpoint == region_f_group[z+1,]$start || region_f_group[z+1,]$end == breakpoint ) { #// breakpoint at exon boundary
							Judge = 1;
							breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_plus_shift)
						} else { #// breakpoint within exon
							m = 1; # set start point = 1
							while ( m <= offset ) { # if breakpoint does not match to exon boundrary exactly, and set a offset value with maximum 5 bp
								if ( AB_order == "downstream" ) {
									breakpoint_down = breakpoint - m;
									if ( breakpoint_down == region_f_group[z+1,]$start || region_f_group[z+1,]$end == breakpoint_down ) { #// breakpoint at exon boundary
										Judge = 1;
										breakpoint_down_relative = IRanges::IRanges(start = breakpoint_down, end = breakpoint_down);
										breakpoint_relative = IRanges::shift(breakpoint_down_relative, shift = tmp_plus_shift);
										break;
									}
								}
								m = m + 1;
							}
							if ( m > offset ) {
								Judge = 2;
								breakpoint_relative = IRanges::shift(breakpoint_relative, shift = tmp_plus_shift)
							}
							break; #// quit the loop
						}
					}
				}
			}
		}
		if ( !is.null(flag) ) { 
			Exon_max = max(region_f_group$EXONRANK) #// get total exon number of the transcript
			Trans_length = dataset[x,]$TXEND - dataset[x,]$TXSTART + 1; #// get transcript length
			tmp = cbind(t(Judge), t(flag$Prop), t(flag$EXONRANK), t(flag$exon), t(Exon_num), t(Exon_max), t(Trans_length), t(chr), t(strand), t(start), t(end));
			JE = rbind(JE, tmp, deparse.level=0); #// extend row of JE data.frame (including Judge, flag, Exon_num....)
			breakpoint_current = IRanges::start(breakpoint_relative); names(breakpoint_current) = name;
			breakpoint_collect = c(breakpoint_collect, breakpoint_current)
		} else {
			tmp = cbind(t(Judge), t(NA), t(NA), t(NA), t(Exon_num), t(NA), t(NA), t(chr), t(strand), t(start), t(end));
			JE = rbind(JE, tmp, deparse.level=0); #// row extension 
		} 
		if ( !is.null(region_f_relative) ) { #// Ideally, region_f_relative should not be NULL
			#// 'region_f_relative' (reduce intron and calculate relative coordinates)
			for (i in seq_along(region_f_relative)) {
				if (i == 1) {
					region_f_relative[i] = IRanges::shift(region_f_relative[i], shift = 1 - IRanges::start(region_f_relative[i]))
				} else {
					tmp_shift = - (IRanges::start(region_f_relative[i]) - IRanges::end(region_f_relative[i-1])) + 1
					region_f_relative[i] = IRanges::shift(region_f_relative[i], shift = tmp_shift)
				}
			}
			region_f$start = IRanges::start(region_f_relative) #// replace relative start coordinates to absolute start coordinates in 'region_f'
			region_f$end = IRanges::end(region_f_relative) #// replace relative end coordinates to absolute end coordinates in 'region_f'
			dataset[x,]$TXSTART = min(region_f$start); #// start of transcript in 'dataset' after reducing intron
			dataset[x,]$TXEND = max(region_f$end); #// end of transcript in 'dataset' after reducing intron
			select_region_f = rbind(select_region_f, region_f) 
		} else {
			stop("Unexpected exon relative coordinate, a bug needs to be fixed!");
		}
	}
	#// build 'transcript' data.frame class, which combines info of dataset and JE (removing rows with NA)
	transcript = cbind(as.data.frame(cbind(dataset$GENEID, dataset$TXNAME, dataset$TXSTART, dataset$TXEND)), JE); 
	transcript = na.omit(transcript) #// remove all NA rows
	if (! is.na(transcript[1,1]) ) {
		names(transcript) = c("GENEID", "TXNAME", "TXSTART", "TXEND", "Judge", "Prop", "EXONRANK", "exon", "Exon_pos", "Exon_num", "Trans_length", "Chrom", "Strand", "GStart", "GEnd")
		transcript$TXSTART = as.numeric(transcript$TXSTART) #// switch to numeric type
		transcript$TXEND = as.numeric(transcript$TXEND) #// switch to numeric type
		transcript$Prop = as.numeric(transcript$Prop)	#// switch to the numeric type
		transcript$EXONRANK = as.numeric(transcript$EXONRANK) #// switch to the numeric type
		transcript$exon = as.character(transcript$exon) #// switch to the string type for exon name
		transcript$Exon_pos = as.character(transcript$Exon_pos) #// switch to the numeric type
		transcript$Exon_num = as.numeric(as.character(transcript$Exon_num)) #// switch to the numeric type
		transcript$Trans_length = as.numeric(as.character(transcript$Trans_length)) #// switch to the numeric type
		transcript$Strand = as.character(transcript$Strand) #// switch to the charater type
		transcript$GStart = as.numeric(as.character(transcript$GStart)) #// switch to the numeric type
		transcript$GEnd = as.numeric(as.character(transcript$GEnd)) #// switch to the numeric type
		#-# levels(transcript$Chrom) = sub("^chr", "", levels(transcript$Chrom), ignore.case=T) #// remove 'chr' 
		#// 'transcript' is a data.frame class used for evaluating breakpoint pos in each transcript, and 'select_region_f' is a data.frame class used for plotTracks
		assemble <- list(transcript=transcript, select_region=select_region_f, breakpoint_collect = breakpoint_collect)
	} else {
		assemble <- list(transcript=NULL, select_region=NULL, breakpoint_collect=NULL)
	}
	return(assemble)
}

